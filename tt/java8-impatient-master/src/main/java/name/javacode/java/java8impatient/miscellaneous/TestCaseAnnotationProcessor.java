package name.javacode.java.java8impatient.miscellaneous;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.toList;
import static javax.lang.model.element.ElementKind.METHOD;
import static javax.tools.Diagnostic.Kind.NOTE;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UncheckedIOException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.SimpleElementVisitor8;
import javax.tools.JavaFileObject;

/**
 * Q13: Repeat the previous exercise (Q12), but build a source-level annotation
 * processor emitting a program that, when executed, runs the tests in its
 * {@code main} method.
 * 
 * @author Abhijit Sarkar
 *
 */
/*
 * c.f. http://www.informit.com/articles/article.aspx?p=2027052&seqNum=6 c.f.
 * http
 * ://programmaticallyspeaking.com/playing-with-java-annotation-processing.html
 * 
 * javac -cp <path to the jar w.r.t. the directory from where this command is
 * ran> -processor <fully qualified name of this class> <path to the source file
 * to be processed w.r.t. the directory from where this command is ran>
 */
@SupportedAnnotationTypes({ "name.javacode.java.java8impatient.miscellaneous.TestCase" })
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class TestCaseAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(final Set<? extends TypeElement> annotations,
	    final RoundEnvironment roundEnv) {
	if (annotations.size() > 1) {
	    throw new IllegalArgumentException(
		    "Can handle only TestCase annotations.");
	}

	final Function<Element, String> keyMapper = element -> element.accept(
		new SimpleElementVisitor8<String, Void>() {
		    @Override
		    public String visitExecutable(final ExecutableElement e,
			    final Void p) {
			/*
			 * Assumes the enclosing element is a class, that is the
			 * annotation scope is method only.
			 */
			return e.getEnclosingElement().asType().toString()
				+ "." + element.getSimpleName();
		    }
		}, null);

	final Function<Element, List<Pair>> valueMapper = element -> element
		.accept(new SimpleElementVisitor8<List<Pair>, Void>() {
		    @Override
		    public List<Pair> visitExecutable(
			    final ExecutableElement e, final Void p) {
			return Stream
				.of(e.getAnnotationsByType(TestCase.class))
				.map(testCase -> new Pair(testCase.param(),
					testCase.expected())).collect(toList());
		    }
		}, null);

	final BinaryOperator<List<Pair>> mergeFunction = (pairs1, pairs2) -> {
	    return Stream.concat(pairs1.stream(), pairs2.stream()).collect(
		    collectingAndThen(toList(), Collections::unmodifiableList));
	};

	final Map<String, List<Pair>> methodMap = Stream
		.concat(roundEnv.getElementsAnnotatedWith(TestCase.class)
			.stream(),
			roundEnv.getElementsAnnotatedWith(TestCases.class)
				.stream())
		.filter(element -> element.getKind() == METHOD)
		.collect(
			Collectors.<Element, String, List<Pair>> toMap(
				keyMapper, valueMapper, mergeFunction));

	/*
	 * Not sure how but the map may be empty. Needs more research.
	 */
	if (!methodMap.isEmpty()) {
	    final PrintWriter out = getOutputWriter();

	    generateTestCasesRunner(methodMap, out);

	    out.close();
	}

	return true;
    }

    private PrintWriter getOutputWriter() {
	final String generatedFilePackage = getClass().getPackage().getName();

	processingEnv.getMessager().printMessage(NOTE,
		"Generating " + generatedFilePackage + ".TestCaseRunner");

	try {
	    final JavaFileObject sourceFile = processingEnv.getFiler()
		    .createSourceFile(generatedFilePackage + ".TestCaseRunner");

	    return new PrintWriter(new OutputStreamWriter(
		    sourceFile.openOutputStream(), UTF_8));
	} catch (IOException e) {
	    throw new UncheckedIOException(e);
	}
    }

    void generateTestCasesRunner(final Map<String, List<Pair>> methodMap,
	    PrintWriter out) {
	final String generatedFilePackage = getClass().getPackage().getName();

	out.format("package %s;%n", generatedFilePackage);
	out.format(
		"%n/* This class is generated by the %s.%n * Do not modify it, it'll be overwritten.%n */",
		getClass().getName());
	out.format("%npublic class TestCaseRunner {");
	out.format("%n\tpublic static void main(String[] args) {");

	out.format("%n\t\tint actual = 0;");

	methodMap
		.forEach((methodName, pairs) -> {
		    pairs.forEach(pair -> {
			out.format("%n\t\tactual = %s(%d);", methodName,
				pair.param);
			out.format("%n\t\tif (actual != %d) {", pair.expected);
			out.format(
				"%n\t\t\tthrow new RuntimeException(\"Expected %d, but actually \" + actual);",
				pair.expected);
			out.format("%n\t\t}%n");
		    });
		});

	out.format("%n\t}"); // end of main
	out.format("%n}%n"); // end of class
    }

    static class Pair {
	private final int param;
	private final int expected;

	Pair(final int param, final int expected) {
	    this.param = param;
	    this.expected = expected;
	}

	@Override
	public String toString() {
	    return "Pair [param=" + param + ", expected=" + expected + "]";
	}
    }
}
